import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import f1_score, classification_report
from imblearn.over_sampling import SMOTE

df = pd.read_csv("transactions.csv")   

df["target"] = df["Category"].astype(str) + " __ " + df["Subcategory"].astype(str)

df = df.dropna(subset=["target"])

class_counts = df["target"].value_counts()
total = len(df)
rare_threshold = 0.05 * total
rare_classes = class_counts[class_counts <= rare_threshold].index.tolist()

print("Всего классов:", df["target"].nunique())
print("5% наименее представленные классы (по числу транзакций):")
print(class_counts.tail(10)) 

df["Date"] = pd.to_datetime(df["Date"])
df["day_of_week"] = df["Date"].dt.dayofweek
df["hour"] = df["Date"].dt.hour

text_features = ["Note"]
cat_features = ["Mode", "Category", "Subcategory"]
num_features = ["Amount", "day_of_week", "hour"]

df["Note"] = df["Note"].fillna("")

X = df[text_features + cat_features + num_features]
y = df["target"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

preprocessor = ColumnTransformer(
    transformers=[
        ("text", TfidfVectorizer(max_features=5000), "Note"),
        ("cat", OneHotEncoder(handle_unknown="ignore"), cat_features),
        ("num", "passthrough", num_features),
    ]
)

#МЕТОД 1: class_weight = "balanced"

model_weighted = Pipeline(steps=[
    ("preprocess", preprocessor),
    ("clf", LogisticRegression(
        max_iter=1000,
        class_weight="balanced",
        n_jobs=-1
    )),
])

model_weighted.fit(X_train, y_train)
y_pred_w = model_weighted.predict(X_test)
macro_f1_w = f1_score(y_test, y_pred_w, average="macro")
print("Macro F1 (class_weight):", macro_f1_w)

report_w = classification_report(y_test, y_pred_w, output_dict=True)
rare_10 = list(class_counts.tail(10).index)
rare_f1_w = {cls: report_w.get(cls, {}).get("f1-score", 0.0) for cls in rare_10}
print("F1 по 10 редким классам (class_weight):", rare_f1_w)

#МЕТОД 2: SMOTE (oversampling)

from imblearn.pipeline import Pipeline as ImbPipeline

model_smote = ImbPipeline(steps=[
    ("preprocess", preprocessor),
    ("smote", SMOTE(random_state=42)),
    ("clf", LogisticRegression(max_iter=1000, n_jobs=-1))
])

model_smote.fit(X_train, y_train)
y_pred_s = model_smote.predict(X_test)
macro_f1_s = f1_score(y_test, y_pred_s, average="macro")
print("Macro F1 (SMOTE):", macro_f1_s)

report_s = classification_report(y_test, y_pred_s, output_dict=True)
rare_f1_s = {cls: report_s.get(cls, {}).get("f1-score", 0.0) for cls in rare_10}
print("F1 по 10 редким классам (SMOTE):", rare_f1_s)

#МЕТОД 3: иерархическое взвешивание 

cat_counts = df["Category"].value_counts()
cat_weights = 1.0 / cat_counts
cat_weights = cat_weights / cat_weights.mean()

class_weights_hier = {}
for t in y.unique():
    cat = t.split(" __ ")[0]
    class_weights_hier[t] = cat_weights.get(cat, 1.0)

model_hier = Pipeline(steps=[
    ("preprocess", preprocessor),
    ("clf", LogisticRegression(
        max_iter=1000,
        n_jobs=-1,
        class_weight=class_weights_hier
    )),
])

model_hier.fit(X_train, y_train)
y_pred_h = model_hier.predict(X_test)
macro_f1_h = f1_score(y_test, y_pred_h, average="macro")
print("Macro F1 (hierarchical):", macro_f1_h)

report_h = classification_report(y_test, y_pred_h, output_dict=True)
rare_f1_h = {cls: report_h.get(cls, {}).get("f1-score", 0.0) for cls in rare_10}
print("F1 по 10 редким классам (hierarchical):", rare_f1_h)
